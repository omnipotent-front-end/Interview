# Web安全

## 网络安全

### CDN劫持如何防护？

[使用SRI解决CDN劫持问题](https://github.com/omnipotent-front-end/blog/blob/master/2019/07/20190704%E4%BD%BF%E7%94%A8SRI%E8%A7%A3%E5%86%B3CDN%E5%8A%AB%E6%8C%81%E9%97%AE%E9%A2%98.md)

### XSS和CSRF了解吗？为什么既要有cookie又要有token？

首先了解token和cookie的区别。

cookie：

登陆后后端生成一个sessionid放在cookie中返回给客户端，并且服务端一直记录着这个sessionid，客户端以后每次请求都会带上这个sessionid，**服务端通过这个sessionid来验证身份之类的操作**。所以**别人拿到了cookie拿到了sessionid后，就可以完全替代你**。

token：

登陆后后端返回一个token给客户端，客户端将这个token存储起来，然后每次客户端请求都需要开发者手动**将token放在header中带过去**，服务端每次只需要对这个token进行验证就能使用token中的信息来进行下一步操作了。

XSS攻击：

用户通过各种方式将恶意代码注入到其他用户的页面中。就可以通过脚本获取信息，发起请求，之类的操作。

CSRF操作：

跨站请求攻击，简单地说，是攻击者通过一些技术手段欺骗用户的浏览器去访问一个自己曾经认证过的网站并运行一些操作（如发邮件，发消息，甚至财产操作如转账和购买商品）。由于浏览器曾经认证过，所以被访问的网站会认为是真正的用户操作而去运行

以一个CSRF例子来说明：

假如一家银行用以运行转账操作的URL地址如下： 

`http://www.examplebank.com/withdraw?account=AccoutName&amount=1000&for=PayeeName`

那么，一个恶意攻击者可以在另一个网站上放置如下代码： `<img src="<http://www.examplebank.com/withdraw?account=Alice&amount=1000&for=Badman>">`
如果有账户名为Alice的用户访问了恶意站点，而她之前刚访问过银行不久，登录信息尚未过期，那么她就会损失1000资金。

上面的两种攻击方式，如果被xss攻击了，不管是token还是cookie，都能被拿到，所以对于xss攻击来说，cookie和token没有什么区别。但是对于csrf来说就有区别了。

以上面的csrf攻击为例：


cookie：用户点击了链接，cookie未失效，导致发起请求后后端以为是用户正常操作，于是进行扣款操作。

token：用户点击链接，**由于浏览器不会自动带上token，所以即使发了请求，后端的token验证不会通过，所以不会进行扣款操作**。

所以总结下来：

1、token不是防止XSS的，而是为了防止CSRF的；

2、CSRF攻击的原因是**浏览器会自动带上cookie，而浏览器不会自动带上token**

参考地址：

[一题](https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/31)

---

### Https中间人攻击是什么？如何防护？

首先需要熟悉[https的握手原理](/cp/network.html#https的握手过程是什么样子的？)


中间人攻击过程如下：

1、服务器向客户端发送公钥。

2、攻击者截获公钥，保留在自己手上。

3、然后攻击者自己生成一个【伪造的】公钥，发给客户端。

4、客户端收到伪造的公钥后，生成加密hash值发给服务器。

5、攻击者获得加密hash值，用自己的私钥解密获得真秘钥。

6、同时生成假的加密hash值，发给服务器。

7、服务器用私钥解密获得假秘钥。

8、服务器用加秘钥加密传输信息

防范方法：

服务端在发送浏览器的公钥中加入CA证书，浏览器可以验证CA证书的有效性。





### XSS是什么，攻击原理，怎么预防？

跨站脚本攻击XSS(cross site scripting)，简单来说，就是用户通过各种方式将恶意代码注入到其他用户的页面中。就可以通过脚本获取信息，发起请求，之类的操作。

攻击类型主要有两种：反射型和存储型。

存储型XSS，持久化，代码是存储在服务器中的，如在个人信息或发表文章等地方，加入代码，**如果没有过滤或过滤不严，那么这些代码将储存到服务器中，用户访问该页面的时候触发代码执行**。这种XSS比较危险，容易造成蠕虫，盗窃cookie等。

反射型XSS，非持久化，需要欺骗用户自己去点击链接才能触发XSS代码（服务器中没有这样的页面和内容），一般容易出现在搜索页面。

简单说了一下如何防御：

- 转义
    前后端在对应的输入展示处进行转义处理。对诸如`<script>、<img>、<a>`等标签进行过滤。

- cookie安全设置
    设置HttpOnly以避免cookie劫持的危险

- CSP
    CSP(content security policy)，是一个额外的安全层，用于检测并削弱某些特定类型的攻击，包括跨站脚本 (XSS) 和数据注入攻击等。

参考：

[内容安全策略( CSP ) - HTTP | MDN](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/CSP)



---

## 密码学


### 数字签名是什么？什么原理？用在哪里？

数字签名（digital signature）是公钥密码的逆应用：**用私钥加密消息，用公钥解密消息**。

信息安全中有三个需要解决的问题：

保密性(Confidentiality)：信息在传输时不被泄露

完整性（Integrity）：信息在传输时不被篡改

有效性（Availability）：信息的使用者是合法的

这三要素统称为CIA Triad。

公钥密码解决保密性问题

数字签名解决完整性问题和有效性问题

用私钥加密的消息称为签名，只有拥有私钥的用户可以生成签名。
用公钥解密签名这一步称为验证签名，所有用户都可以验证签名(因为公钥是公开的)

原理：


数字签名技术是将原文通过特定HASH函数得到的摘要信息**用发送者的私钥加密**，与原文一起传送给接收者。接收者只有**用发送者的公钥才能解密**被加密的摘要信息，然后用HASH函数对收到的原文提炼出一个摘要信息，与解密得到的摘要进行对比。哪怕只是一个字符不相同，用HASH函数生成的摘要就一定不同。如果比对结果一致，则说明收到的信息是完整的，在传输过程中没有被修改，否则信息一定被修改过，因此**数字签名能够验证信息的完整性**。



参考：

[数字签名原理及作用 - 知乎](https://zhuanlan.zhihu.com/p/25162134)

[什么是数字签名和证书？ - 简书](https://www.jianshu.com/p/9db57e761255)

### 数字证书有什么用？

数字证书简称CA，它由权威机构给某网站颁发的一种认可凭证，这个凭证是被大家（浏览器）所认可的，为什么需要用数字证书呢，难道有了数字签名还不够安全吗？

如果有人（张三）用自己的公钥把真实服务器发送给浏览器的公钥替换了，于是张三用自己的私钥执行相同的步骤对文本Hash、数字签名，最后得到的结果都没什么问题，但事实上浏览器看到的东西却不是真实服务器给的，而是被张三从里到外（公钥到私钥）换了一通。那么如何保证你现在使用的公钥就是真实服务器发给你的呢？

我们就用数字证书来解决这个问题。数字证书一般由数字证书认证机构（Certificate Authority）颁发，证书里面包含了真实服务器的公钥和网站的一些其他信息，数字证书机构用自己的私钥加密后发给浏览器，浏览器使用数字证书机构的公钥解密后得到真实服务器的公钥。这个过程是建立在被大家所认可的证书机构之上得到的公钥，所以这是一种安全的方式。



参考：

[数字签名、数字证书与HTTPS是什么关系？ - 知乎](https://www.zhihu.com/question/52493697)

### 非对称加密、对称加密和单向散列加密的区别？

**对称加密**：

指的就是**加、解密使用的同是一串密钥**，所以被称做对称加密。对称加密只有一个密钥作为私钥。

常见的对称加密算法：DES，AES等。

优缺点：

对称加密相比非对称加密算法来说，加解密的效率要高得多、加密速度快。但是缺陷在于对于密钥的管理和分发上比较困难，不是非常安全，密钥管理负担很重。

**非对称加密**：

指的是**加、解密使用不同的密钥，一把作为公开的公钥，另一把作为私钥。公钥加密的信息，只有私钥才能解密。反之，私钥加密的信息，只有公钥才能解密**。 

举个例子，你向某公司服务器请求公钥，服务器将公钥发给你，你使用公钥对消息加密，那么只有私钥的持有人才能对你的消息解密。与对称加密不同的是，公司服务器不需要将私钥通过网络发送出去，因此安全性大大提高。

最常用的非对称加密算法：RSA

优缺点：

安全性更高，公钥是公开的，密钥是自己保存的，不需要将私钥给别人。缺点：加密和解密花费时间长、速度慢，只适合对少量数据进行加密。

**散列**

也称为散列值或消息摘要 ，是一种与基于密钥（对称密钥或公钥）的加密不同的数据转换类型。

散列就是通过把一个叫做散列算法的单向数学函数应用于数据，**将任意长度的一块数据转换为一个定长的、不可逆转的数字，其长度通常在128～256位之间**。所产生的散列值的长度应足够长，因此使找到两块具有相同散列值的数据的机会很少。

如发件人生成邮件的散列值并加密它，然后将它与邮件本身一起发送。而收件人同时解密邮件和散列值，并由接收到的邮件产生另外一个散列值，然后将两个散列值进行比较。如果两者相同，邮件极有可能在传输期间没有发生任何改变。

优缺点：

 散列算法处理数据的速度比公钥算法快得多。散列数据还缩短了要签名的数据的长度，因而加快了签名过程。但不可逆转，无法解密。

参考：

[对称加密、非对称加密、RSA(总结) - 掘金](https://juejin.im/post/5abb6c8651882555784e051d)

### 了不了解密钥轮替，有什么意义？

轮替密钥不会停用或销毁以前的密钥版本。以前的密钥版本将不再是主密钥版本，但仍可用于解密数据。

通过轮替密钥可以轻松地遵循标准安全做法，例如支付卡行业数据安全标准 (PCI DSS) 要求。定期轮替密钥是安全性方面的一种最佳做法，原因如下：

为了限制可用于对特定密钥版本进行密码分析的加密消息数。同样，为了限制可用于对特定密钥版本进行密码分析的加密字节总数。密钥生命周期建议是特定于算法的，并且基于生成的消息数或加密的总字节数。例如，伽罗瓦/计数器模式 (GCM) 中的对称密钥的推荐密钥生命周期基于加密消息的数量，如 https://nvlpubs.nist.gov/nistpubs/Legacy/SP/nistspecialpublication800-38d.pdf 中所述。

为了确保系统已准备好应对需要转为使用更强大的算法的情况。如果正在进行的操作不包含密钥轮替，则系统将依赖于特定密钥，从而难以在突发事件发生后启动密钥轮替。

同样，为了确保系统已准备好应对密钥泄露的情况。不应在突发事件实时恢复期间首次尝试密钥轮替。

为了减少密钥版本被破解时不受保护的密文量。

为了防止使用被破解或疑似被破解的密钥版本。


**使用场景比如koa的app.keys，egg在对cookie进行加密时，就使用了密钥轮替，从而保证密钥替换后，老的cookie用户，不会导致校验失败**。

[egg-cookies源码分析](https://github.com/FunnyLiu/egg-cookies/tree/readsource)


参考：

[密钥轮替  |  Cloud KMS  |  Google Cloud](https://cloud.google.com/kms/docs/key-rotation)


### 列举下常见的加密算法和各自的使用场景

<img src="https://raw.githubusercontent.com/brizer/graph-bed/master/img/20191128103951.png"/>

#### md5

MD5是一种基于哈希函数的单向加密算法，只能加密、无法解密，它是把一个任意长度的字节串变换成一定长的大整数。请注意我使用了"字节串"而不是"字符串"这个词，是因为这种变换只与字节的值有关，与字符集或编码方式无关。MD5将任意长度的"字节串"变换成一个128bit的大整数，并且它是一个不可逆的字符串变换算法，换句话说就是，即使你看到源程序和算法描述，也无法将一个MD5的值变换回原始的字符串，从数学原理上说，是因为原始的字符串有无穷多个，这有点象不存在反函数的数学函数。**MD5是不可逆的只有加密没有解密**。


加强加密性

单纯的 MD5加密是不安全的，可通过撞库的方式来暴力破解出来的，因此可以通过多种方式来进行加强

1、加盐

最好配合 MD5加盐的方式来对密文进行再次处理，即往明文中插入或拼接一个随机的字符串，然后再进行加密。

盐值加如的代码例子如下

password = [passwordstringByAppendingString:salt];    

2、乱序

先对明文进行md5加密，然后对密文进行乱序

#### base64

Base64编码的思想是：采用64个基本的ASCII码字符对数据进行重新编码。它将需要编码的数据拆分成字节数组，以3个字节为一组，按顺序排列24位数据，再把这24位数据分成4组，即每组6位；再在每组的的最高位前补两个0凑足一个字节，这样就把一个3字节为一组的数据重新编码成了4个字节；当所要编码的数据的字节数不是3的整倍数，也就是说在分组时最后一组不够3个字节，这时在最后一组填充1到2个0字节，并在最后编码完成后在结尾添加1到2个=号。

特点：

-数据加密之后，数据量会变大，变大1/3左右。

-可进行反向解密。

-编码后有个非常显著的特点，末尾有个=号。

#### DES

数据加密标准算法(Data Encryption Standard)，和BASE64最明显的区别就是有一个公有密钥，该密钥既用于加密、也用于解密，并且要求密钥是一个长度至少大于8位的字符串。使用DES加密、解密的核心是确保工作密钥的安全性。

#### AES

高级加密标准Advanced Encryption Standard简称：AES，在密码学中又称Rijndael加密法，是美国联邦政府采用的一种区块加密标准。它是一种对称加密算法，这个标准也替代原先的DES标准，已经被多方分析且广为全世界所使用。AES设计有三个密钥长度:128、192、256位，相对而言，AES的128密钥比DES的56密钥强1021倍。AES算法主要包括三个方面：轮变化、圈数和密钥扩展。
 
特点

AES作为新一代的数据加密标准汇聚了强安全性、高性能、高效率、易用和灵活，在软件及硬件上都能快速地加解密且只需要很少的存储资源等优点。


#### RSA


RSA是目前最有影响力的公钥加密算法，它能够抵抗到目前为止已知的绝大多数密码攻击，已被ISO推荐为公钥数据加密标准。RSA的公开密钥密码体制就是使用不同的加密密钥与解密密钥，是一种“由已知加密密钥推导出解密密钥在计算上是不可行的”密码体制。通常是先生成一对RSA密钥，其中之一是保密密钥，由用户保存；另一个为公开密钥，可对外公开，甚至可在网络服务器中注册。为提高保密强度，RSA密钥至少为500位长，一般推荐使用1024位，这就使加密的计算量很大。RSA算法是一种非对称密码算法，所谓非对称，就是指该算法需要一对密钥，使用其中一个加密，则需要用另一个才能解密。

RSA算法是非对称加密算法的典型代表，既能加密、又能解密。和对称加密算法比如DES的明显区别在于用于加密、解密的密钥是不同的。使用RSA算法，只要密钥足够长(一般要求1024bit)，加密的信息是不能被破解的。用户通过https协议访问服务器时，就是使用非对称加密算法进行数据的加密、解密操作的。

服务器发送数据给客户端时使用私钥（private key）进行加密，并且使用加密之后的数据和私钥生成数字签名（digitalsignature）并发送给客户端。客户端接收到服务器发送的数据会使用公钥（public key）对数据来进行解密，并且根据加密数据和公钥验证数字签名的有效性，防止加密数据在传输过程中被第三方进行了修改。

客户端发送数据给服务器时使用公钥进行加密，服务器接收到加密数据之后使用私钥进行解密。

特点

- 密钥管理的方便，计算量很大速度相对比较慢。

- 安全性很高，能够抵抗到目前为止已知的绝大多数密码攻击。

参考：

[常用的加解密算法的优缺点、应用场景总结 - 简书](https://www.jianshu.com/p/ea229b329347)

### 综合各方面，考虑一个性能和安全都比较好的加密方式

基于md5和aes的超强度加密算法：

用户的密码是一定的,但是每次发送给网络的密码都不同。相同的密码相同的加密算法,每次获得的值不同。

客户端和服务器端要求时间一致，时间精度越高，越安全

假如约定网络请求延时3秒

客户端：

a. 对请求参数one进行一次AES对称加密(或者其他的对称加密)，后形成密文two。

b.对当前时间进行一次md5加密后形成three时间密文

c.将密文two与密文three进行拼接(或其他算法)，再进行一次AES对称加密(或者其他对称加密)形成four密文。

d.将密文four发送给服务器。

服务端： 

a.对收到的密文four进行一次AES对称解密得到two+three的密文结合体。

b.以收到的时间为基准与前3秒时间遍历成md5密文，并与结合体进行对比，假如匹配上了，就将two密文解密出来。 

c.对two密文进行最后的AES对称加密然后就得出正确的请求参数

