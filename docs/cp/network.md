# 计算机网络

## HTTP

### http2多路复用是什么?解决了什么问题？

在 HTTP/1 中，每次请求都会建立一次HTTP连接，也就是我们常说的3次握手4次挥手，这个过程在一次请求过程中占用了相当长的时间，即使开启了 Keep-Alive ，解决了多次连接的问题，但是依然有两个效率上的问题：

第一个：串行的文件传输。当请求a文件时，b文件只能等待，等待a连接到服务器、服务器处理文件、服务器返回文件，这三个步骤。我们假设这三步用时都是1秒，那么a文件用时为3秒，b文件传输完成用时为6秒，依此类推。（注：此项计算有一个前提条件，就是浏览器和服务器是单通道传输）

第二个：连接数过多。我们假设Apache设置了最大并发数为300，因为浏览器限制，浏览器发起的最大请求数为6，也就是服务器能承载的最高并发为50，当第51个人访问时，就需要等待前面某个请求处理完成。

HTTP/2的多路复用就是为了解决上述的两个性能问题。
在 HTTP/2 中，有两个非常重要的概念，分别是**帧（frame）和流（stream）**。
帧代表着最小的数据单位，每个帧会标识出该帧属于哪个流，流也就是多个帧组成的数据流。

多路复用，就是**在一个 TCP 连接中可以存在多条流。换句话说，也就是可以发送多个请求，对端可以通过帧中的标识知道属于哪个请求**。通过这个技术，可以避免 HTTP 旧版本中的队头阻塞问题，极大的提高传输性能。

### https的握手过程是什么样子的？
开始加密通信之前，客户端和服务端必须建立连接和交互参数，这个过程就是握手。

<img src="https://raw.githubusercontent.com/brizer/graph-bed/master/img/20190712110314.png"/>

第一步：客户端 say hello, 向服务端发送自己生成的 random 数，和自己支持的加密方法。

第二步：服务端接收消息后，又向客户端发送自己生成的 random 数、SSL 证书，确定使用的加密方法。

第三步：客户端读取证书信息，确认证书有效，然后自己再生成一个 random 数，并使用证书的公钥进行加密，发送给服务端。

第四步：服务端使用自己本地的私钥，解密获取客户端的随机数。

第五步：客户端和服务端使用这三个随机数生成 对话密钥, 用来加密接下来的对话过程。

如果每次建立连接都去进行这五步，那么会很浪费时间。 所以这里有 sessionID 和 session ticket 两种。

session ID，记录有本次的握手存在，再次发送信息时，客户端发送该ID，服务器确认该编号存在，双方就不再进行握手阶段剩余的步骤，而直接用已有的对话密钥进行加密通信。

但是它的缺点在于session ID往往只保留在一台服务器上。所以，如果客户端的请求发到另一台服务器，就无法恢复对话。session ticket就是为了解决这个问题而诞生的，目前只有Firefox和Chrome浏览器支持。session ticket是加密的，只有服务器才能解密，其中包括本次对话的主要信息，比如对话密钥和加密方法。当服务器收到session ticket以后，解密后就不必重新生成对话密钥了。

参考：

[配置SSL，方法及须知原理](https://blog.csdn.net/dadadeganhuo/article/details/80265808)


### 想办法在https的网站下进行http的请求？

```
<script> 均默认阻止
XMLHttpRequest 阻止
<a> 不会产生混合内容
<img> 仍会加载混合内容图像，但也会向用户显示警告
```

或者加上
``` html
<meta http-equiv="Content-Security-Policy" content="upgrade-insecure-requests" />
```


## TCP

### 如何理解三次握手和四次挥手？

一张图片解决问题：

<img src="https://raw.githubusercontent.com/brizer/graph-bed/master/img/20190710171408.png"/>

## 浏览器缓存

### 请求时浏览器缓存 from memory cache 和 from disk cache 的区别是什么？

**Memory Cache 也就是内存中的缓存**，主要包含的是当前中页面中已经抓取到的资源,例如页面上**已经下载的样式、脚本、图片等**。

读取内存中的数据肯定比磁盘快,内存缓存虽然读取高效，可是缓存持续性很短，会随着进程的释放而释放。 一旦我们关闭 Tab 页面，内存中的缓存也就被释放了。

当我们访问过页面以后，再次刷新页面，可以发现很多数据都来自于内存缓存。

**Disk Cache 也就是存储在硬盘中的缓存**，读取速度慢点，但是什么都能存储到磁盘中，比之 Memory Cache 胜在容量和存储时效性上。

- 对于大文件来说，大概率是不存储在内存中的，反之优先
- 当前系统内存使用率高的话，文件优先存储进硬盘

参考地址：
[深入理解浏览器的缓存机制](https://www.jianshu.com/p/54cc04190252)