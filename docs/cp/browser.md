# 浏览器相关


## 应用


### 移动端浏览器点击事件触发顺序

touchstart --> mouseover(有的浏览器没有实现) --> mousemove(一次) -->mousedown --> mouseup --> click -->touchend


---



## 原理

### 请求时浏览器缓存 from memory cache 和 from disk cache 的区别是什么？

**Memory Cache 也就是内存中的缓存**，主要包含的是当前中页面中已经抓取到的资源,例如页面上**已经下载的样式、脚本、图片等**。

读取内存中的数据肯定比磁盘快,内存缓存虽然读取高效，可是缓存持续性很短，会随着进程的释放而释放。 一旦我们关闭 Tab 页面，内存中的缓存也就被释放了。

当我们访问过页面以后，再次刷新页面，可以发现很多数据都来自于内存缓存。

**Disk Cache 也就是存储在硬盘中的缓存**，读取速度慢点，但是什么都能存储到磁盘中，比之 Memory Cache 胜在容量和存储时效性上。

- 对于大文件来说，大概率是不存储在内存中的，反之优先
- 当前系统内存使用率高的话，文件优先存储进硬盘

参考地址：
[深入理解浏览器的缓存机制](https://www.jianshu.com/p/54cc04190252)


### 谈谈V8中的GC策略

Nodejs和chrome都是基于V8引擎来渲染的，所以了解V8引擎是至关重要的。

简单来说，垃圾回收是指回收那些在应用程序中不在引用的对象，当一个对象无法从根节点访问这个对象就会做为垃圾回收的候选对象。这里的根对象可以为全局对象、局部变量，无法从根节点访问指的也就是不会在被任何其它活动对象所引用。

**V8的内存限制**：内存在服务端本来就是一个寸土寸金的东西，**在 V8 中限制 64 位的机器大约 1.4GB**，32 位机器大约为 0.7GB。因此，对于一些大内存的操作需谨慎否则**超出 V8 内存限制将会造成进程退出**。

V8 将堆分为两类**新生代和老生代**，**新空间中的对象都非常小大约为 1-8MB**，这里的垃圾回收也很快。新生代空间中垃圾回收过程中幸存下来的对象会被提升到老生代空间。

**Scavenge算法**：

由于**新空间中的垃圾回收很频繁**，因此它的处理方式必须非常的快，**采用的 Scavenge 算法**。

Scavenge 是一种复制算法，新生代空间会被一分为二划分成两个相等大小的 from-space 和 to-space。它的工作方式是将 from space 中存活的对象复制出来，然后移动它们到 to space 中或者被提升到老生代空间中，对于 from space 中没有存活的对象将会被释放。完成这些复制后在将 from space 和 to space 进行互换。

Scavenge 算法非常快适合少量内存的垃圾回收，但是它有很大的空间开销，对于新生代少量内存是可以接受的。

在使用 Scavenge 算法则会有两大缺点一是将会重复的**复制存活对象使得效率低下，二是对于空间资源的浪费**，所以**在老生代空间中采用了 Mark-Sweep（标记清除） 和 Mark-Compact（标记整理） 算法**。

**Mark-Sweep算法**：

Mark-Sweep 处理时分为标记、清除两个步骤，与 Scavenge 算法只复制活对象相反的是在老生代空间中由于活对象占多数 Mark-Sweep 在标记阶段遍历堆中的所有对象**仅标记活对象把未标记的死对象清除**，这时一次标记清除就已经完成了。

**看似一切 perfect 但是还遗留一个问题，被清除的对象遍布于各内存地址，产生很多内存碎片**。

**Mark-Compact算法**：

在老生代空间中为了解决 Mark-Sweep 算法的内存碎片问题，引入了 Mark-Compact（标记整理算法），其在工作过程中将活着的对象往一端移动，这时内存空间是紧凑的，移动完成之后，直接清理边界之外的内存。

V8 使用了不同的垃圾回收算法 Scavenge、Mark-Sweep、Mark-Compact。这三种垃圾回收算法都避免不了在进行垃圾回收时需要将应用程序暂停，待垃圾回收完成之后在恢复应用逻辑，对于新生代空间来说由于很快所以影响不大，但是对于老生代空间由于存活对象较多，停顿还是会造成影响的，因此，V8 又新增加了增量标记的方式减少停顿时间。



参考：

[Node.js内存管理和V8垃圾回收机制](https://zhuanlan.zhihu.com/p/72380507?utm_source=wechat_session&utm_medium=social&utm_oi=41809770184704&from=singlemessage&isappinstalled=0&wechatShare=1&s_r=0)


### 谈谈浏览器加载的逻辑

当浏览器获得一个html文件时，会”自上而下“加载，并在加载过程中进行解析渲染。 

加载过程中遇到外部css文件，浏览器另外发出一个请求，来获取css文件。 

遇到图片资源，浏览器也会另外发出一个请求，来获取图片资源。

**css/图片这些异步请求，并不会影响html文档进行加载**。

但是**当文档加载过程中遇到js文件，html文档会挂起渲染（加载解析渲染同步）的线程，不仅要等待文档中js文件加载完毕，还要等待解析执行完毕，才可以恢复html文档的渲染线程**。

一个**不太严谨但方便记忆的口诀：JS 全阻塞，CSS 半阻塞JS**

- JS会阻塞后续 DOM 解析以及其它资源(如 CSS，JS 或图片资源)的加载。
- CSS不阻塞DOM的加载和解析（它只阻塞DOM的渲染呈现。这里谈加载），不会阻塞其它资源(如图片)的加载，但是会阻塞 后续JS 文件的执行（原因之一是，js执行代码可能会依赖到css样式。css只阻塞执行而不阻塞js的加载）。
- 鉴于上面的特性，当css后面存在js的时候，css会间接地阻塞js后面资源的加载（css阻塞js，js阻塞其他资源 ）。
- 现代浏览器会进行 prefetch 优化，浏览器在获得 html 文档之后会对页面上引用的资源进行提前下载 。       

外联js文件使用defer属性和asyn可以达到异步非阻塞加载的效果，**由于现代浏览器都存在 prefetch，所以 defer, async 可能并没有太多的用途**，可以作为了解扩展知识，仅仅将脚本文件放到 body 底部(但还是在</body>之前)就可以起到很不错的优化效果（遵循先解析再渲染再执行script这个顺序）。当把js放在最后的时候，其实浏览器将自动忽略</body>标签，从而自动在最后的最后补上</body>。


### 谈谈浏览器解析过程

1、浏览器通过请求的 URL 进行域名解析，向服务器发起请求，接收文件（HTML、CSS、JS、Images等等）。

2、HTML 文件加载后，开始构建 DOM Tree（DOM树）

3、CSS 样式文件加载后，开始解析和构建 CSS Rule Tree

4、Javascript 脚本文件加载后， 通过 DOM API 和 CSSOM API 来操作 DOM Tree 和 CSS Rule Tree


### 谈谈浏览器渲染过程


浏览器采用流式布局模型（Flow Based Layout）

浏览器会把HTML解析成DOM，把CSS解析成CSSOM，**DOM和CSSOM合并就产生了渲染树（Render Tree）**。

有了RenderTree，我们就知道了所有节点的样式，然后计算他们在页面上的大小和位置，最后把节点绘制到页面上。

由于浏览器使用流式布局，对Render Tree的计算通常只需要遍历一次就可以完成，但table及其内部元素除外，他们可能需要多次计算，通常要花3倍于同等元素的时间，这也是**为什么要避免使用table布局**的原因之一。


### 重排和重绘是什么？

由于**节点的几何属性发生改变或者由于样式发生改变**而**不会影响布局**的，称为**重绘**，例如outline, visibility, color、background-color等，重绘的代价是高昂的，因为浏览器必须验证DOM树上其他节点元素的可见性。

**重排**是布局或者几何属性需要改变。重排是影响浏览器性能的关键因素，因为其变化涉及到部分页面（或是整个页面）的布局更新。一个元素的重排可能会导致了其所有子元素以及DOM中紧随其后的节点、祖先节点元素的随后的重排。

**重排必定会发生重绘，重绘不一定会引发重排。**

### 如何避免重排和重绘？

js方面：

现代浏览器做了一定的优化，通过队列机制来批量更新布局，浏览器会把修改操作放在队列中，至少一个帧（即16.6ms）才会清空队列，但当你获取布局信息的时候，队列中可能有会影响这些属性或方法返回值的操作，即使没有，浏览器也会强制清空队列，触发重排与重绘来确保返回正确的值。

主要包括以下属性或方法：

offsetTop、offsetLeft、offsetWidth、offsetHeight
scrollTop、scrollLeft、scrollWidth、scrollHeight
clientTop、clientLeft、clientWidth、clientHeight

width、height

getComputedStyle()


所以，我们应该**避免频繁的使用上述的属性，他们都会强制渲染刷新队列**。


css方面：

- 使用 transform 替代 top

- 使用 visibility 替换 display: none ，因为前者只会引起重绘，后者会引发回流（改变了布局

- 避免使用table布局，可能很小的一个小改动会造成整个 table 的重新布局。

- 尽可能在DOM树的最末端改变class，回流是不可避免的，但可以减少其影响。尽可能在DOM树的最末端改变class，可以限制了回流的范围，使其影响尽可能少的节点。

- 避免设置多层内联样式，CSS 选择符从右往左匹配查找，避免节点层级过多。

- 将动画效果应用到position属性为absolute或fixed的元素上，避免影响其他元素的布局，这样只是一个重绘，而不是回流，同时，控制动画速度可以选择 requestAnimationFrame，详见探讨 requestAnimationFrame。

- 避免使用CSS表达式，可能会引发回流。

- 将频繁重绘或者回流的节点设置为图层，图层能够阻止该节点的渲染行为影响别的节点，例如will-change、video、iframe等标签，浏览器会自动将该节点变为图层。

- CSS3 硬件加速（GPU加速），使用css3硬件加速，可以让transform、opacity、filters这些动画不会引起回流重绘 。但是对于动画的其它属性，比如background-color这些，还是会引起回流重绘的，不过它还是可以提升这些动画的性能。



### 浏览器中输入url到页面呈现到底发生了什么？

总体分为以下几个步骤：

1、DNS解析

2、TCP连接

3、发送HTTP请求

4、服务器处理请求并返回HTTP报文

5、浏览器解析渲染页面

6、连接结束



DNS解析参考：[简单说下dns解析的过程](/cp/network.html#%E7%AE%80%E5%8D%95%E8%AF%B4%E4%B8%8Bdns%E8%A7%A3%E6%9E%90%E7%9A%84%E8%BF%87%E7%A8%8B)

TCP连接参考：[如何理解三次握手和四次挥手？](/cp/network.html#%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%92%8C%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B%EF%BC%9F)

HTTP参考：[https的握手过程是什么样子的？](/cp/network.html#https%E7%9A%84%E6%8F%A1%E6%89%8B%E8%BF%87%E7%A8%8B%E6%98%AF%E4%BB%80%E4%B9%88%E6%A0%B7%E5%AD%90%E7%9A%84%EF%BC%9F)

浏览器加载渲染参考：[谈谈浏览器加载的逻辑](/cp/browser.html#%E8%B0%88%E8%B0%88%E6%B5%8F%E8%A7%88%E5%99%A8%E5%8A%A0%E8%BD%BD%E7%9A%84%E9%80%BB%E8%BE%91)


### 浏览器的事件流模型是什么样子的？为什么一般在冒泡阶段处理事件？如何在冒泡阶段处理？

模型为：

捕获-》目标-》冒泡

在冒泡阶段处理的原因是：

1、兼容性：

对于绑定事件，ie低版本的浏览器是用attachEvent，而高版本ie和标准浏览器用的是addEventListener，**attachEvent不能指定绑定事件发生在捕获阶段还是冒泡阶段，它只能将事件绑定到冒泡阶段**，但是并不意味这低版本的ie没有事件捕获，它也是先发生事件捕获，再发生事件冒泡，只不过这个过程无法通过程序控制。

2、为事件代理(委托)提供条件，即事件代理依赖事件冒泡。

通过addEventListener的第三个参数来决定，为true则是捕获，为false或默认都是冒泡。


参考：

[浏览器事件模型中捕获阶段、目标阶段、冒泡阶段实例详解 - 本期节目 - SegmentFault 思否](https://segmentfault.com/a/1190000003482372)

[浏览器事件有哪些过程? 为什么一般在冒泡阶段，而不是在捕获阶段注册监听? · Issue #11 · maoxiaoke/one-day-one-puzzle](https://github.com/maoxiaoke/one-day-one-puzzle/issues/11)