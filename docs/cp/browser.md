# 浏览器相关

## 浏览器缓存

### 请求时浏览器缓存 from memory cache 和 from disk cache 的区别是什么？

**Memory Cache 也就是内存中的缓存**，主要包含的是当前中页面中已经抓取到的资源,例如页面上**已经下载的样式、脚本、图片等**。

读取内存中的数据肯定比磁盘快,内存缓存虽然读取高效，可是缓存持续性很短，会随着进程的释放而释放。 一旦我们关闭 Tab 页面，内存中的缓存也就被释放了。

当我们访问过页面以后，再次刷新页面，可以发现很多数据都来自于内存缓存。

**Disk Cache 也就是存储在硬盘中的缓存**，读取速度慢点，但是什么都能存储到磁盘中，比之 Memory Cache 胜在容量和存储时效性上。

- 对于大文件来说，大概率是不存储在内存中的，反之优先
- 当前系统内存使用率高的话，文件优先存储进硬盘

参考地址：
[深入理解浏览器的缓存机制](https://www.jianshu.com/p/54cc04190252)


## 垃圾回收

### 谈谈V8中的GC策略

Nodejs和chrome都是基于V8引擎来渲染的，所以了解V8引擎是至关重要的。

简单来说，垃圾回收是指回收那些在应用程序中不在引用的对象，当一个对象无法从根节点访问这个对象就会做为垃圾回收的候选对象。这里的根对象可以为全局对象、局部变量，无法从根节点访问指的也就是不会在被任何其它活动对象所引用。

**V8的内存限制**：内存在服务端本来就是一个寸土寸金的东西，**在 V8 中限制 64 位的机器大约 1.4GB**，32 位机器大约为 0.7GB。因此，对于一些大内存的操作需谨慎否则**超出 V8 内存限制将会造成进程退出**。

V8 将堆分为两类**新生代和老生代**，**新空间中的对象都非常小大约为 1-8MB**，这里的垃圾回收也很快。新生代空间中垃圾回收过程中幸存下来的对象会被提升到老生代空间。

**Scavenge算法**：

由于**新空间中的垃圾回收很频繁**，因此它的处理方式必须非常的快，**采用的 Scavenge 算法**。

Scavenge 是一种复制算法，新生代空间会被一分为二划分成两个相等大小的 from-space 和 to-space。它的工作方式是将 from space 中存活的对象复制出来，然后移动它们到 to space 中或者被提升到老生代空间中，对于 from space 中没有存活的对象将会被释放。完成这些复制后在将 from space 和 to space 进行互换。

Scavenge 算法非常快适合少量内存的垃圾回收，但是它有很大的空间开销，对于新生代少量内存是可以接受的。

在使用 Scavenge 算法则会有两大缺点一是将会重复的**复制存活对象使得效率低下，二是对于空间资源的浪费**，所以**在老生代空间中采用了 Mark-Sweep（标记清除） 和 Mark-Compact（标记整理） 算法**。

**Mark-Sweep算法**：

Mark-Sweep 处理时分为标记、清除两个步骤，与 Scavenge 算法只复制活对象相反的是在老生代空间中由于活对象占多数 Mark-Sweep 在标记阶段遍历堆中的所有对象**仅标记活对象把未标记的死对象清除**，这时一次标记清除就已经完成了。

**看似一切 perfect 但是还遗留一个问题，被清除的对象遍布于各内存地址，产生很多内存碎片**。

**Mark-Compact算法**：

在老生代空间中为了解决 Mark-Sweep 算法的内存碎片问题，引入了 Mark-Compact（标记整理算法），其在工作过程中将活着的对象往一端移动，这时内存空间是紧凑的，移动完成之后，直接清理边界之外的内存。

V8 使用了不同的垃圾回收算法 Scavenge、Mark-Sweep、Mark-Compact。这三种垃圾回收算法都避免不了在进行垃圾回收时需要将应用程序暂停，待垃圾回收完成之后在恢复应用逻辑，对于新生代空间来说由于很快所以影响不大，但是对于老生代空间由于存活对象较多，停顿还是会造成影响的，因此，V8 又新增加了增量标记的方式减少停顿时间。






参考：

[Node.js内存管理和V8垃圾回收机制](https://zhuanlan.zhihu.com/p/72380507?utm_source=wechat_session&utm_medium=social&utm_oi=41809770184704&from=singlemessage&isappinstalled=0&wechatShare=1&s_r=0)