# 编译原理

## 基础

### 机器码和字节码有什么区别？

**机器码(machine code)**，学名机器语言指令，有时也被称为原生码（Native Code），是电脑的CPU可直接解读的数据。

通常意义上来理解的话，机器码就是计算机可以直接执行，并且执行速度最快的代码。

**字节码**(Bytecode)是一种包含执行程序、由一序列 op 代码/数据对 组成的二进制文件。字节码是一种中间码，它比机器码更抽象，需要直译器转译后才能成为机器码的中间代码。

通常情况下它是已经经过编译，但与特定机器码无关。字节码通常不像源码一样可以让人阅读，而是编码后的数值常量、引用、指令等构成的序列。

字节码在运行时通过JVM（JAVA虚拟机）做一次转换生成机器指令，因此能够更好的跨平台运行。

**字节码是一种中间状态（中间码）的二进制代码（文件）**。需要直译器转译后才能成为机器码。

可以通过javascript进行对比：

<img src="https://raw.githubusercontent.com/brizer/graph-bed/master/img/20200119174020.png"/>

机器码所占用的空间远远超过了字节码，所以使用字节码可以减少系统的内存使用。

参考

[机器码和字节码 - 第五空间](https://blog.csdn.net/limonzet/article/details/77892159)

### 编程语言的runtime和compiler有什么区别？请以js为例说明下。

**compiler也就是编译器**是将代码编译为机器代码的工具。

我们说的的**js引擎比如V8将js代码编译成了字节码，只针对少量场景使用其TurboFan模块编译为了优化过的机器码**，所以其TurboFan可以勉强算作编译器。

关于字节码和机器代码的区别可以参考[机器码和字节码有什么区别？](/cp/compiler.html#%E6%9C%BA%E5%99%A8%E7%A0%81%E5%92%8C%E5%AD%97%E8%8A%82%E7%A0%81%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F)

关于v8工作原理，可以参考[简单说下v8引擎工作原理](/cp/browser.html#%E7%AE%80%E5%8D%95%E8%AF%B4%E4%B8%8Bv8%E5%BC%95%E6%93%8E%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86)

汇编代码与机器代码是严格一一对应的，也很容易互相转换，这也是反编译的原理。

而**runtime，是基于compiler之上的运行环境**。比如浏览器端的document和node端的fs的提供者这种。

以`require('asd.js')`为例，这句话是什么意思？v8是不关心的。
v8只关心你调了一个require函数，参数是个字符串，它只是执行这个函数；但是require这个函数到底能干嘛，是Node定义的。

所以在node架构图中：

<img src="https://raw.githubusercontent.com/brizer/graph-bed/master/img/20190701094137.png"/>

下面两层都是runtime，而v8中的TurboFan最多算半个compiler。

参考：

[v8引擎是如何工作的](https://blog.fundebug.com/2019/07/16/how-does-v8-work/)


### 对JIT的理解

即时编译(JIT)技术，是指字节码配合解释器和编译器。可以先了解[v8引擎是如何工作的](https://blog.fundebug.com/2019/07/16/how-does-v8-work/)，简单来说，就是指解释器Ignition在解释执行字节码 的同时，收集代码信息，当它发现某一部分代码变热了之后，TurboFan编译器便闪亮登场，把热点的字节 码转换为机器码，并把转换后的机器码保存起来，以备下次使用。

对于JavaScript工作引擎，除了V8使用了“字节码+JIT”技术之外，苹果的SquirrelFish Extreme和Mozilla 的SpiderMonkey也都使用了该技术，Java和Python的虚拟机也都是基于这种 技术实现的。

用一张图来表示：

<img src="https://raw.githubusercontent.com/brizer/graph-bed/master/img/20200119174623.png"/>

---


### 哈希是做什么？

哈希是一种通过对数据进行压缩, 从而提高效率的一种解决方法。

### 哈希存储的使用场景？

哈希表的哈希函数输入一个键，并向返回一个哈希表的索引。可能的键的集合很大，但是哈希函数值的集合只是表的大小。

哈希函数的其他用途包括密码系统、消息摘要系统、数字签名系统，为了使这些应用程序按预期工作，冲突的概率必须非常低，因此需要一个具有非常大的可能值集合的散列函数。

密码系统:给定用户密码，操作系统计算其散列，并将其与存储在文件中的该用户的散列进行比较。(不要让密码很容易被猜出散列到相同的值)。

消息摘要系统:给定重要消息，计算其散列，并将其与消息本身分开发布。希望检查消息有效性的读者也可以使用相同的算法计算其散列，并与发布的散列进行比较。(不要希望伪造消息很容易，仍然得到相同的散列)。

参考：

[你还应该知道的哈希冲突解决策略 - vivo互联网技术 - OSCHINA - 中文开源技术交流社区](https://my.oschina.net/vivotech/blog/4268016)


### 哈希的冲突是什么？

来看一个简单的实例吧，假设采用hash函数：H(K) = K mod M，插入这些值：217、701、19、30、145


```
H(K) = 217 % 7 = 0

H(K) = 701 % 7 = 1

H(K) = 19 % 7 = 2

H(K) = 30 % 7 = 2

H(K) = 145 % 7 = 5
```

上面实例很明显 19 和 30 就发生冲突了。


[你还应该知道的哈希冲突解决策略 - vivo互联网技术 - OSCHINA - 中文开源技术交流社区](https://my.oschina.net/vivotech/blog/4268016)


### 哈希存储的键冲突（散列碰撞）可以有哪些解决方案？

哈希是一种通过对数据进行压缩, 从而提高效率的一种解决方法，但由于哈希函数有限，数据增大等缘故，哈希冲突成为数据有效压缩的一个难题。

冲突解决技术可以分为两类：开散列方法( open hashing，也称为拉链法，separate chaining )和闭散列方法( closed hashing，也称为开地址方法，open addressing )。这两种方法的不同之处在于：开散列法把发生冲突的关键码存储在散列表主表之外，而闭散列法把发生冲突的关键码存储在表中另一个槽内。

下面介绍业内比较流行的hash冲突解决策略：

线性探测(Linear probing)

双重哈希(Double hashing)

随机散列(Random hashing)

分离链接(Separate chaining)

上面线性探测、双重哈希、随机散列都是闭散列法，而分离链接则是开散列法。



参考：

[你还应该知道的哈希冲突解决策略 - vivo互联网技术 - OSCHINA - 中文开源技术交流社区](https://my.oschina.net/vivotech/blog/4268016)



## 原理

### 编译器的基本工作流程


编译一般分为三个步骤：

1、词法分析(laxical Analysis) 

词法分析的意思就是，将代码块切分成最小的单位。这些最小单位称为token。比如 var a = 2;可以切分成var,a,=,2。

2、语法分析(Syntactic Analysis) 

将词法单元转换成一个有层级，代表程序语法结构的树，这就是我们经常说的AST，抽象语法树。
注意：词法分析跟语法分析不是完全独立的，而是交错运行的。也就是说，并不是等所有的token都生成之后，才用语法分析器来处理。一般都是每取得一个token，就开始用语法分析器来处理了。

AST可是所有编译器以及转换器的基础核心，我们常用的babel转码过程就是先将ES6的代码编成AST，然后转换成ES5的AST，最后由这个AST还原出ES5代码。

3、代码生成(Code Genaration)

最后一步就是将AST转成计算机可以识别的机器指令码。



参考：

[从敲下一行JS代码到这行代码被执行，中间发生了什么？](https://mp.weixin.qq.com/s/D2aPqf9qcfFJLSGTE4G8kg)